- interface(인터페이스)
    - 컬렉션들이 가져야 하는 조작에 대한 설명과 함께 기능들을 추상적으로 표현한 거들이다.
    - 계층적인 구조이다.
    - ex) 객체에 대한 검색과 삭제와 관련된 기능들
- implementations(구현 객체)
    - 위의 interface 들을 구체적으로 구현한 클래스들을 의미한다. 그러므로 재사용을 할 수 있도록 하는 자료의 구조이다.
- Algorithms(메서드)
    - interface를 구현한 객체들의 검색 그리고 정렬과 같은 유용한 동작들, 즉 메서드들을 의미한다.

-- 인터페이스 간의 상속 구조
                                - BlockingQueue<E>
                - Queue<E>      
Collection<E>   - LIST<E>   
                - Set<E>        
                                - SortedSet<E>

Map<K, V>       - SortedSet<k,V>
                - ConcureentMap<K,V>

## Set 인터페이스
- 특별한 기준에 맞춰서 정렬되지 않는다.
- 중복 x
- HashSet Set :
    - 인터페이스를 구현하고 있으며 내부적을 **HashMap을 사용**하고 있다. 얻어지는 **Iterator 의 정렬 상태를 보장하지 못하므로** **특정한 기준으로 정렬을 이루고 있지 않으며** 저장 및 검출과 같은 **동작에는 일정한 시간이 필요**하다
- TreeSet :
    - 내부적으로 Set 인터페이스를 구현하고 있으며 **TreeMap에 의해 후원**을 받는다. 그리고 기본적으로 얻어지는 **Iterator의 요소들은 오름차순 정렬 상태**를 유지하고 있다.

### HashSet
→ 기본적인 Set 인터페이스를 구현하고 있다.
- 정렬순서나 반복처리를 할 때 **처리순서에 대한 기준은 없다**.
- 반복 처리에 대해서는 저장된 요소의 수와는 별도로 용량에 비례하는 시간이 필요하므로 반복 처리하는 성능이 중요한 프로그램에서는 초기용량을 너무 높게 설정하지 않는게 중요하다

### List 인터페이스
→ **시퀀스**라고도 하며 **시작과 끝이 선정**되어 저장되는 요소들을 **일괄적인 정렬상태로 유지**하면서 **요소들의 저장**이 이루어진다.
**배열과는 다르게** **가변적인 길이**를 가지고 있다.

- List  -Stack
        -Vector
        -ArrayList

-- List의 구현 클래스
- Stack : -> 가방
    - **후입선출**의 구조다(Last In First Out) → **LIFO**
    - Vector 클래스로부터 파생된 클래스
    - **저장**할 때는 **push()** 빼낼 때는 **pop()**
- Vector :
    - 배열과 같이 **정수 인덱스로 접근이 가능**.
    - Vector의 크기는 **가변적**이다.
    - 요소들의 작업을 위해 Iterator로 작업가능하고, **스레드 동기화가 지원되는 List 구조이다**
- ArrayList :
    - List 인터페이스를 구현할 뿐 아니라 **배열의 크기를 조작**가능
    - **공백을 포함한 모든 요소들을 저장 o**
    - Vector와 유사하지만 스레드 동기화는 지원 x


